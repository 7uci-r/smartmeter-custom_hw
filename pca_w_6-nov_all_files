/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file           : main.c
  * @brief          : THDC parser + PCA pruning integration (UART2 DMA RX, debug UART3)
  ******************************************************************************
  */
/* USER CODE END Header */

#include "main.h"
#include "dma.h"
#include "usart.h"
#include "usb_otg.h"
#include "gpio.h"

#include <string.h>
#include <stdio.h>
#include <stdarg.h>
#include <stdint.h>

#include "pca_prune.h" /* existing module providing pca_prune_feed_sample() + pca_prune_maybe_run_and_report() */

#define HAVE_PCA_PRUNE 1

/* USER CONFIG (must match usart.h) */
#ifndef RX_DMA_BUF_LEN
#define RX_DMA_BUF_LEN 128
#endif

/* THDC frame constants */
#define FRAME_TOTAL_LEN   46
#define FRAME_PAYLOAD_LEN 39
#define FRAME_HEADER0 'T'
#define FRAME_HEADER1 'H'
#define FRAME_HEADER2 'D'
#define FRAME_HEADER3 'C'

/* DMA rx buffer: defined in usart.c; extern in usart.h */
extern volatile uint8_t rx_dma_buf[RX_DMA_BUF_LEN];

/* parser state */
static uint8_t frame_buf[FRAME_TOTAL_LEN];
static size_t frame_idx = 0;
static int parser_state = 0;
static uint16_t dma_last_pos = 0;

/* parsed values exposed to main loop */
static volatile float parsed_voltage = 0.0f;
static volatile float parsed_current = 0.0f;
static volatile float parsed_frequency = 0.0f;
static volatile float parsed_apparent = 0.0f;
static volatile float parsed_active = 0.0f;
static volatile float parsed_pf = 0.0f;
static volatile char  parsed_pfSign = ' ';

/* frame-ready flag set by parser when a valid frame decoded */
static volatile uint8_t frame_ready_flag = 0;

/* Blocking debug print using huart3 (PuTTY) */
static void dbg_print(const char *fmt, ...)
{
    char tmp[256];
    va_list ap;
    va_start(ap, fmt);
    int n = vsnprintf(tmp, sizeof(tmp), fmt, ap);
    va_end(ap);
    if (n > 0) {
        uint16_t len = (uint16_t)((n < (int)sizeof(tmp)) ? n : (int)sizeof(tmp)-1);
        HAL_UART_Transmit(&huart3, (uint8_t *)tmp, len, HAL_MAX_DELAY);
    }
}

/* CRC & BE helpers (identical to your previous working code) */
static uint16_t crc16_modbus(const uint8_t *data, uint16_t len)
{
    uint16_t crc = 0xFFFF;
    for (uint16_t pos = 0; pos < len; pos++) {
        crc ^= data[pos];
        for (uint8_t i = 0; i < 8; i++) {
            if (crc & 0x0001) crc = (crc >> 1) ^ 0xA001;
            else crc >>= 1;
        }
    }
    return crc;
}

static uint32_t read_u32_be(const uint8_t *p)
{
    return ((uint32_t)p[0] << 24) | ((uint32_t)p[1] << 16) | ((uint32_t)p[2] << 8) | (uint32_t)p[3];
}
static uint16_t read_u16_be(const uint8_t *p)
{
    return (uint16_t)((p[0] << 8) | p[1]);
}

/* Parser state-machine: feed a byte at a time (same logic you used earlier) */
static void parser_feed_byte(uint8_t b)
{
    switch (parser_state) {
    case 0:
        if (b == FRAME_HEADER0) {
            frame_buf[0] = b;
            frame_idx = 1;
            parser_state = 1;
        }
        break;
    case 1:
        if (frame_idx == 1 && b == FRAME_HEADER1) {
            frame_buf[frame_idx++] = b;
        } else {
            if (b == FRAME_HEADER0) {
                frame_buf[0] = b; frame_idx = 1; parser_state = 1;
            } else {
                parser_state = 0; frame_idx = 0;
            }
        }
        if (frame_idx == 2) parser_state = 2;
        break;
    case 2:
        if (frame_idx == 2 && b == FRAME_HEADER2) {
            frame_buf[frame_idx++] = b;
            parser_state = 3;
        } else {
            if (b == FRAME_HEADER0) { frame_buf[0] = b; frame_idx = 1; parser_state = 1; }
            else { parser_state = 0; frame_idx = 0; }
        }
        break;
    case 3:
        if (frame_idx == 3 && b == FRAME_HEADER3) {
            frame_buf[frame_idx++] = b;
            parser_state = 4;
        } else {
            if (b == FRAME_HEADER0) { frame_buf[0] = b; frame_idx = 1; parser_state = 1; }
            else { parser_state = 0; frame_idx = 0; }
        }
        break;
    case 4:
        /* length byte */
        frame_buf[frame_idx++] = b;
        if (b != FRAME_PAYLOAD_LEN) {
            dbg_print("Length mismatch (got %u, expected %u). Resync.\r\n", b, (unsigned)FRAME_PAYLOAD_LEN);
            if (b == FRAME_HEADER0) { frame_buf[0] = b; frame_idx = 1; parser_state = 1; }
            else { parser_state = 0; frame_idx = 0; }
        } else {
            parser_state = 5;
        }
        break;
    case 5:
        /* collecting remainder */
        frame_buf[frame_idx++] = b;
        if (frame_idx >= FRAME_TOTAL_LEN) {
            /* full frame received */
            uint16_t crc_calc = crc16_modbus(&frame_buf[5], FRAME_PAYLOAD_LEN);
            uint16_t crc_rx = ((uint16_t)frame_buf[44] << 8) | (uint16_t)frame_buf[45];
            if (crc_calc == crc_rx) {
                /* parse payload & publish parsed_* variables */
                const uint8_t *pl = &frame_buf[5];
                uint32_t voltage_mV     = read_u32_be(&pl[0]);
                uint32_t current_mA     = read_u32_be(&pl[4]);
                uint32_t realPower_w    = read_u32_be(&pl[8]);
                uint32_t reactivePower  = read_u32_be(&pl[12]);
                uint32_t apparentPower  = read_u32_be(&pl[16]);
                uint16_t instPF_raw     = read_u16_be(&pl[20]);
                char pfSign             = (char)pl[22];
                uint16_t freq_raw       = read_u16_be(&pl[23]);
                uint32_t kWh_raw        = read_u32_be(&pl[25]);
                uint32_t kVAh_raw       = read_u32_be(&pl[29]);
                uint8_t day             = pl[33];
                uint8_t month           = pl[34];
                uint8_t year_off        = pl[35];
                uint8_t hour            = pl[36];
                uint8_t minute          = pl[37];
                uint8_t second          = pl[38];

                /* convert to floats and publish atomically */
                /* Your earlier working scaling: voltage was divided by 100.0 or 1000? Keep consistent:
                   use /100.0 here only as example — we will apply *10 in main when printing as you requested. */
                parsed_voltage  = ((float)voltage_mV) / 1000.0f; /* will apply *10 in main if needed */
                parsed_current  = ((float)current_mA) / 1000.0f;
                parsed_active   = (float)realPower_w;
                parsed_apparent = (float)apparentPower;
                parsed_pf       = ((float)instPF_raw) / 100.0f;
                parsed_pfSign   = pfSign;
                parsed_frequency = ((float)freq_raw) / 100.0f; /* will apply *10 in main if needed */

                /* set frame ready for main loop */
                frame_ready_flag = 1;
            } else {
                dbg_print("CRC FAIL calc=0x%04X rx=0x%04X\r\n", crc_calc, crc_rx);
            }
            /* reset parser */
            parser_state = 0;
            frame_idx = 0;
        }
        break;
    default:
        parser_state = 0;
        frame_idx = 0;
        break;
    }
}

/* Helper: poll DMA circular buffer and feed new bytes to parser */
static void parser_poll_dma(void)
{
    if (huart2.hdmarx == NULL) return; /* safety */
    uint16_t new_pos = (uint16_t)(RX_DMA_BUF_LEN - __HAL_DMA_GET_COUNTER(huart2.hdmarx));
    if (new_pos == dma_last_pos) return;

    if (new_pos > dma_last_pos) {
        for (uint16_t i = dma_last_pos; i < new_pos; ++i) parser_feed_byte(rx_dma_buf[i]);
    } else {
        /* wrapped */
        for (uint16_t i = dma_last_pos; i < RX_DMA_BUF_LEN; ++i) parser_feed_byte(rx_dma_buf[i]);
        for (uint16_t i = 0; i < new_pos; ++i) parser_feed_byte(rx_dma_buf[i]);
    }
    dma_last_pos = new_pos;
}

/* Application entry point --------------------------------------------------*/
int main(void)
{
    HAL_Init();

    /* System clock - keep your CubeMX generated function or existing one */
    SystemClock_Config();

    /* Initialize peripherals */
    MX_GPIO_Init();
    MX_DMA_Init();

    /* IMPORTANT: Initialize debug UART (USART3) BEFORE any debug prints */
    MX_USART3_UART_Init();       /* debug port (PuTTY) */

    /* Quick sanity print to confirm debug port works right after init */
    dbg_print("\r\n[BOOT] Debug UART (USART3) initialized\r\n");

    /* Continue initializing other peripherals */
    MX_USB_OTG_FS_PCD_Init();    /* optional */
    MX_USART2_UART_Init();       /* meter RX port (PA2/PA3) */

    /* initialize PCA module (if present) */
#ifdef HAVE_PCA_PRUNE
    pca_prune_init();
#endif

    /* start UART2 DMA circular receive */
    if (HAL_UART_Receive_DMA(&huart2, (uint8_t *)rx_dma_buf, RX_DMA_BUF_LEN) != HAL_OK) {
        dbg_print("Failed to start UART2 DMA receive\r\n");
    } else {
        dbg_print("UART2 DMA RX started, buf len=%u\r\n", (unsigned)RX_DMA_BUF_LEN);
    }

    /* init dma_last_pos to current DMA write index (safety check) */
    if (huart2.hdmarx != NULL) {
        dma_last_pos = (uint16_t)(RX_DMA_BUF_LEN - __HAL_DMA_GET_COUNTER(huart2.hdmarx));
    } else {
        dma_last_pos = 0;
        dbg_print("Warning: huart2.hdmarx is NULL when reading DMA counter\r\n");
    }

    dbg_print("THDC parser + PCA pruning up. Waiting for frames...\r\n");

    /* main loop */
    while (1) {
        /* feed incoming bytes from DMA into parser */
        parser_poll_dma();

        /* when a good frame is decoded, process it here */
        if (frame_ready_flag) {
            frame_ready_flag = 0;

            /* apply scaling corrections you requested: multiply voltage and frequency by 10 */
            float voltage = parsed_voltage * 10.0f;
            float current = parsed_current;
            float freq    = parsed_frequency * 10.0f;
            float apparent = parsed_apparent;
            float active   = parsed_active;
            float pf       = parsed_pf;
            char pfSign    = parsed_pfSign;

            /* timestamp */
            uint32_t ms = HAL_GetTick();
            uint32_t total_sec = ms / 1000;
            uint32_t hr = (total_sec / 3600) % 24;
            uint32_t min = (total_sec / 60) % 60;
            uint32_t sec = total_sec % 60;

            dbg_print("%02lu:%02lu:%02lu | V=%.3f I=%.3f P=%.1f PF=%c%.2f F=%.2f\r\n",
                      hr, min, sec,
                      voltage, current, active, pfSign, pf, freq);

            /* Build sample with order expected by pca_prune.h (N_VARS must match pca_prune.h) */
#if N_VARS >= 6
            float sample[N_VARS];
            sample[0] = current;
            sample[1] = voltage;
            sample[2] = active;
            sample[3] = apparent;
            sample[4] = pf;
            sample[5] = freq;
            for (int i = 6; i < N_VARS; ++i) sample[i] = 0.0f;
#else
            float sample[6] = { current, voltage, active, apparent, pf, freq };
#endif

            /* Feed PCA module (use your existing API) */
#ifdef HAVE_PCA_PRUNE
            pca_prune_feed_sample(sample);
            /* The PCA module prints report internally using dbg_print when it runs */
            pca_prune_maybe_run_and_report();
#else
            /* If you use the alternative run_pca_batch API, call it from where appropriate */
#endif
        }

        HAL_Delay(1);
    }
}

/* SystemClock_Config - keep your CubeMX generated code here or the one you used before */
void SystemClock_Config(void)
{
  RCC_OscInitTypeDef RCC_OscInitStruct = {0};
  RCC_ClkInitTypeDef RCC_ClkInitStruct = {0};

  __HAL_RCC_PWR_CLK_ENABLE();
  __HAL_PWR_VOLTAGESCALING_CONFIG(PWR_REGULATOR_VOLTAGE_SCALE1);

  /* example HSE + PLL config — keep your previously working config instead if needed */
  RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE;
  RCC_OscInitStruct.HSEState = RCC_HSE_BYPASS;
  RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON;
  RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE;
  RCC_OscInitStruct.PLL.PLLM = 8;
  RCC_OscInitStruct.PLL.PLLN = 384;
  RCC_OscInitStruct.PLL.PLLP = RCC_PLLP_DIV4;
  RCC_OscInitStruct.PLL.PLLQ = 8;
  RCC_OscInitStruct.PLL.PLLR = 2;
  if (HAL_RCC_OscConfig(&RCC_OscInitStruct) != HAL_OK) {
    Error_Handler();
  }

  RCC_ClkInitStruct.ClockType = RCC_CLOCKTYPE_HCLK|RCC_CLOCKTYPE_SYSCLK
                              |RCC_CLOCKTYPE_PCLK1|RCC_CLOCKTYPE_PCLK2;
  RCC_ClkInitStruct.SYSCLKSource = RCC_SYSCLKSOURCE_PLLCLK;
  RCC_ClkInitStruct.AHBCLKDivider = RCC_SYSCLK_DIV1;
  RCC_ClkInitStruct.APB1CLKDivider = RCC_HCLK_DIV2;
  RCC_ClkInitStruct.APB2CLKDivider = RCC_HCLK_DIV1;
  if (HAL_RCC_ClockConfig(&RCC_ClkInitStruct, FLASH_LATENCY_3) != HAL_OK) {
    Error_Handler();
  }
}

/* Error handler */
void Error_Handler(void)
{
  __disable_irq();
  while (1) { }
}




/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    usart.c
  * @brief   This file provides code for the configuration
  *          of the USART instances and the RX DMA buffer definition.
  ******************************************************************************
  */
/* USER CODE END Header */

#include "main.h"    /* for Error_Handler prototype and HAL includes */
#include "usart.h"

/* Define the RX DMA buffer here exactly once (volatile since DMA writes). */
volatile uint8_t rx_dma_buf[RX_DMA_BUF_LEN];

/* HAL handles (definition here, declared extern in usart.h) */
UART_HandleTypeDef huart2;
UART_HandleTypeDef huart3;
DMA_HandleTypeDef hdma_usart2_rx;

/* USART2 init function (meter input) */
void MX_USART2_UART_Init(void)
{
  huart2.Instance = USART2;
  huart2.Init.BaudRate = 38400; /* meter baud as you specified */
  huart2.Init.WordLength = UART_WORDLENGTH_8B;
  huart2.Init.StopBits = UART_STOPBITS_1;
  huart2.Init.Parity = UART_PARITY_NONE;
  huart2.Init.Mode = UART_MODE_TX_RX;
  huart2.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart2.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart2) != HAL_OK)
  {
    Error_Handler();
  }
}

/* USART3 init function (debug -> USB-UART to PC) */
void MX_USART3_UART_Init(void)
{
  huart3.Instance = USART3;
  huart3.Init.BaudRate = 115200; /* debug/putty */
  huart3.Init.WordLength = UART_WORDLENGTH_8B;
  huart3.Init.StopBits = UART_STOPBITS_1;
  huart3.Init.Parity = UART_PARITY_NONE;
  huart3.Init.Mode = UART_MODE_TX_RX;
  huart3.Init.HwFlowCtl = UART_HWCONTROL_NONE;
  huart3.Init.OverSampling = UART_OVERSAMPLING_16;
  if (HAL_UART_Init(&huart3) != HAL_OK)
  {
    Error_Handler();
  }
}

/* MSP init: configure GPIOs, DMA and NVIC for both UARTs */
void HAL_UART_MspInit(UART_HandleTypeDef* uartHandle)
{
  GPIO_InitTypeDef GPIO_InitStruct = {0};

  if(uartHandle->Instance==USART2)
  {
    /* USART2 clock enable */
    __HAL_RCC_USART2_CLK_ENABLE();

    /* GPIOA clock for PA2(TX) PA3(RX) */
    __HAL_RCC_GPIOA_CLK_ENABLE();
    /**USART2 GPIO Configuration
        PA2 -> USART2_TX
        PA3 -> USART2_RX
    */
    GPIO_InitStruct.Pin = GPIO_PIN_2|GPIO_PIN_3;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART2;
    HAL_GPIO_Init(GPIOA, &GPIO_InitStruct);

    /* USART2 DMA Init - RX */
    __HAL_RCC_DMA1_CLK_ENABLE();
    hdma_usart2_rx.Instance = DMA1_Stream5;
    hdma_usart2_rx.Init.Channel = DMA_CHANNEL_4;
    hdma_usart2_rx.Init.Direction = DMA_PERIPH_TO_MEMORY;
    hdma_usart2_rx.Init.PeriphInc = DMA_PINC_DISABLE;
    hdma_usart2_rx.Init.MemInc = DMA_MINC_ENABLE;
    hdma_usart2_rx.Init.PeriphDataAlignment = DMA_PDATAALIGN_BYTE;
    hdma_usart2_rx.Init.MemDataAlignment = DMA_MDATAALIGN_BYTE;
    hdma_usart2_rx.Init.Mode = DMA_CIRCULAR;
    hdma_usart2_rx.Init.Priority = DMA_PRIORITY_MEDIUM;
    hdma_usart2_rx.Init.FIFOMode = DMA_FIFOMODE_DISABLE;
    if (HAL_DMA_Init(&hdma_usart2_rx) != HAL_OK)
    {
      Error_Handler();
    }

    /* Link DMA handle to UART handle */
    __HAL_LINKDMA(uartHandle, hdmarx, hdma_usart2_rx);

    /* Optional: if you want USART2 IRQ */
    HAL_NVIC_SetPriority(USART2_IRQn, 0, 0);
    HAL_NVIC_EnableIRQ(USART2_IRQn);
    /* DMA IRQ (stream5) enabled in MX_DMA_Init usually */
  }
  else if(uartHandle->Instance==USART3)
  {
    /* USART3 clock enable */
    __HAL_RCC_USART3_CLK_ENABLE();

    /* GPIOD clock for PD8(TX) PD9(RX) */
    __HAL_RCC_GPIOD_CLK_ENABLE();
    /**USART3 GPIO Configuration
        PD8 -> USART3_TX
        PD9 -> USART3_RX
    */
    GPIO_InitStruct.Pin = GPIO_PIN_8|GPIO_PIN_9;
    GPIO_InitStruct.Mode = GPIO_MODE_AF_PP;
    GPIO_InitStruct.Pull = GPIO_NOPULL;
    GPIO_InitStruct.Speed = GPIO_SPEED_FREQ_VERY_HIGH;
    GPIO_InitStruct.Alternate = GPIO_AF7_USART3;
    HAL_GPIO_Init(GPIOD, &GPIO_InitStruct);
  }
}

void HAL_UART_MspDeInit(UART_HandleTypeDef* uartHandle)
{
  if(uartHandle->Instance==USART2)
  {
    __HAL_RCC_USART2_CLK_DISABLE();
    HAL_GPIO_DeInit(GPIOA, GPIO_PIN_2|GPIO_PIN_3);
    HAL_DMA_DeInit(uartHandle->hdmarx);
    HAL_NVIC_DisableIRQ(USART2_IRQn);
  }
  else if(uartHandle->Instance==USART3)
  {
    __HAL_RCC_USART3_CLK_DISABLE();
    HAL_GPIO_DeInit(GPIOD, GPIO_PIN_8|GPIO_PIN_9);
  }
}





/* USER CODE BEGIN Header */
/**
  ******************************************************************************
  * @file    usart.h
  * @brief   This file contains all the function prototypes for
  *          the USART peripherals and the shared RX DMA buffer.
  ******************************************************************************
  */
/* USER CODE END Header */
#ifndef __USART_H__
#define __USART_H__

#ifdef __cplusplus
extern "C" {
#endif

#include "stm32f4xx_hal.h"

/* RX DMA buffer size (used by main.c parser) */
#ifndef RX_DMA_BUF_LEN
#define RX_DMA_BUF_LEN 128
#endif

/* Exposed UART handles (definition in usart.c) */
extern UART_HandleTypeDef huart2;
extern UART_HandleTypeDef huart3;
extern DMA_HandleTypeDef hdma_usart2_rx;

/* RX DMA buffer: defined in usart.c, extern here for other modules */
extern volatile uint8_t rx_dma_buf[RX_DMA_BUF_LEN];

/* Init functions */
void MX_USART2_UART_Init(void);
void MX_USART3_UART_Init(void);

#ifdef __cplusplus
}
#endif

#endif /* __USART_H__ */



#ifndef PCA_PRUNE_H
#define PCA_PRUNE_H

#include <stdint.h>

/* Keep these consistent with your main project */
#ifndef N_VARS
#define N_VARS 6   /* current, voltage, active, apparent, pf, freq */
#endif

#ifndef BATCH_M
#define BATCH_M 60
#endif

/* Public API - used by main.c */
void pca_prune_init(void);
void pca_prune_feed_sample(const float sample[N_VARS]);

/* Run pruning when enough samples accumulated. If run, it prints report via dbg_print()
   and resets the internal batch. Returns 1 if run, 0 otherwise. */
int pca_prune_maybe_run_and_report(void);

#endif /* PCA_PRUNE_H */





/*
 * Core/Src/pca_prune.c
 *
 * PCA + pruning module (top-1 PCA) with verbose diagnostics.
 *
 * Expects dbg_print(const char *fmt, ...) implemented in main.c
 */

#include "pca_prune.h"
#include <string.h>
#include <stdio.h>
#include <math.h>
#include "usart.h"
extern UART_HandleTypeDef huart3;

#include <stdarg.h>

void dbg_print(const char *fmt, ...) {
    char buf[256];
    va_list args;
    va_start(args, fmt);
    vsnprintf(buf, sizeof(buf), fmt, args);
    va_end(args);
    HAL_UART_Transmit(&huart3, (uint8_t*)buf, strlen(buf), HAL_MAX_DELAY);
}

/* Expect dbg_print implemented in main.c (blocking via huart3) */
extern void dbg_print(const char *fmt, ...);

/* Internal storage */
static float data_buf[BATCH_M][N_VARS];
static int sample_count = 0;

/* helpers */
static void zero_buf(void) {
    memset(data_buf, 0, sizeof(data_buf));
    sample_count = 0;
}

/* init */
void pca_prune_init(void) {
    zero_buf();
    dbg_print("[PCA] pca_prune_init: BATCH_M=%d N_VARS=%d\n", BATCH_M, N_VARS);
}

/* copy a sample (N_VARS floats) into internal buffer.
   Diagnostic print added so we can confirm feed operations. */
void pca_prune_feed_sample(const float sample[N_VARS]) {
    if (sample == NULL) return;
    if (sample_count < BATCH_M) {
        for (int j = 0; j < N_VARS; ++j) data_buf[sample_count][j] = sample[j];
        sample_count++;
        dbg_print("[PCA] fed sample #%d: [", sample_count);
        for (int j = 0; j < N_VARS; ++j) dbg_print("%.3f%s", sample[j], (j+1==N_VARS) ? "" : ", ");
        dbg_print("]\r\n");
    } else {
        /* rolling: drop oldest */
        memmove(&data_buf[0], &data_buf[1], sizeof(float) * N_VARS * (BATCH_M - 1));
        for (int j = 0; j < N_VARS; ++j) data_buf[BATCH_M - 1][j] = sample[j];
        dbg_print("[PCA] buffer full -> rolling, still count=%d\n", sample_count);
    }
}

/* compute column means */
static void compute_means(float means[N_VARS]) {
    for (int j = 0; j < N_VARS; ++j) means[j] = 0.0f;
    if (sample_count <= 0) return;
    for (int i = 0; i < sample_count; ++i)
        for (int j = 0; j < N_VARS; ++j)
            means[j] += data_buf[i][j];
    float inv = 1.0f / (float)sample_count;
    for (int j = 0; j < N_VARS; ++j) means[j] *= inv;
}

/* compute unbiased covariance matrix (N_VARS x N_VARS) */
static void compute_covariance(const float means[N_VARS], float cov[N_VARS][N_VARS]) {
    for (int i = 0; i < N_VARS; ++i)
        for (int j = 0; j < N_VARS; ++j)
            cov[i][j] = 0.0f;
    if (sample_count < 2) return;
    for (int t = 0; t < sample_count; ++t) {
        for (int i = 0; i < N_VARS; ++i) {
            float a = data_buf[t][i] - means[i];
            for (int j = 0; j < N_VARS; ++j) {
                float b = data_buf[t][j] - means[j];
                cov[i][j] += a * b;
            }
        }
    }
    float denom = 1.0f / (float)(sample_count - 1);
    for (int i = 0; i < N_VARS; ++i)
        for (int j = 0; j < N_VARS; ++j)
            cov[i][j] *= denom;
}

/* power iteration (top-1 eigenvector) */
static void power_iteration_top1(const float cov[N_VARS][N_VARS], float eig[N_VARS]) {
    /* initialize */
    for (int i = 0; i < N_VARS; ++i) eig[i] = 1.0f; /* simple seed */
    /* normalize seed */
    {
        float s = 0.0f;
        for (int i = 0; i < N_VARS; ++i) s += eig[i]*eig[i];
        s = sqrtf(s); if (s <= 1e-12f) s = 1.0f;
        for (int i = 0; i < N_VARS; ++i) eig[i] /= s;
    }
    /* iterate */
    for (int it = 0; it < 100; ++it) {
        float y[N_VARS];
        for (int i = 0; i < N_VARS; ++i) { y[i] = 0.0f; for (int j = 0; j < N_VARS; ++j) y[i] += cov[i][j] * eig[j]; }
        /* norm */
        float norm = 0.0f;
        for (int i = 0; i < N_VARS; ++i) norm += y[i]*y[i];
        if (norm <= 1e-20f) break;
        norm = sqrtf(norm);
        /* compute difference to check convergence */
        float diff = 0.0f;
        for (int i = 0; i < N_VARS; ++i) {
            float v = y[i]/norm;
            float d = v - eig[i];
            diff += d*d;
            eig[i] = v;
        }
        if (diff < 1e-12f) break;
    }
}

/* project to top-1 component to get scores */
static void project_scores(const float means[N_VARS], const float eig[N_VARS], float scores[BATCH_M]) {
    for (int t = 0; t < sample_count; ++t) {
        float s = 0.0f;
        for (int j = 0; j < N_VARS; ++j) s += (data_buf[t][j] - means[j]) * eig[j];
        scores[t] = s;
    }
}

/* reconstruct from scores */
static void reconstruct_from_scores(const float means[N_VARS], const float eig[N_VARS], const float scores[BATCH_M], float recon[BATCH_M][N_VARS]) {
    for (int t = 0; t < sample_count; ++t)
        for (int j = 0; j < N_VARS; ++j)
            recon[t][j] = means[j] + scores[t] * eig[j];
}

/* compute MSE between data_buf and recon */
static float compute_mse_internal(const float recon[BATCH_M][N_VARS]) {
    double sse = 0.0;
    for (int t = 0; t < sample_count; ++t)
        for (int j = 0; j < N_VARS; ++j) {
            double d = (double)data_buf[t][j] - (double)recon[t][j];
            sse += d * d;
        }
    double denom = (double)sample_count * (double)N_VARS;
    if (denom <= 0.0) return 0.0f;
    return (float)(sse / denom);
}

/* compute total variance of original data (used to estimate savings) */
static float compute_total_variance(const float means[N_VARS]) {
    double s = 0.0;
    for (int t = 0; t < sample_count; ++t)
        for (int j = 0; j < N_VARS; ++j) {
            double d = (double)data_buf[t][j] - (double)means[j];
            s += d*d;
        }
    double denom = (double)sample_count * (double)N_VARS;
    if (denom <= 0.0) return 0.0f;
    return (float)(s / denom);
}

/* The main public function: if enough samples accumulated, run PCA, print report, reset buffer.
   Adds diagnostics for sample_count and time-based trigger. */
int pca_prune_maybe_run_and_report(void) {
    static uint32_t last_run_ms = 0;
    uint32_t now_ms = HAL_GetTick();

    dbg_print("[PCA] maybe_run called: sample_count=%d last_run=%lu now=%lu elapsed=%lu\n",
              sample_count, (unsigned long)last_run_ms, (unsigned long)now_ms, (unsigned long)(now_ms - last_run_ms));

    /* Trigger if buffer is full OR 60s passed since last run and we have at least some samples */
    if (sample_count < BATCH_M && (now_ms - last_run_ms) < 60000UL) {
        dbg_print("[PCA] Not running: sample_count=%d elapsed=%lums (need %d or 60000ms)\n",
                  sample_count, (unsigned long)(now_ms - last_run_ms), BATCH_M);
        return 0;
    }
    if (sample_count < 4) {
        dbg_print("[PCA] Not enough samples to run PCA (have %d)\n", sample_count);
        return 0;
    }

    dbg_print("[PCA] Running PCA with %d samples (forced by timer/full)\n", sample_count);

    /* 1) Means */
    float means[N_VARS];
    compute_means(means);

    /* 2) Covariance */
    float cov[N_VARS][N_VARS];
    compute_covariance(means, cov);

    /* 3) Top-1 eigvec */
    float eigvec[N_VARS];
    power_iteration_top1(cov, eigvec);

    /* 4) Project -> scores */
    float scores[BATCH_M];
    project_scores(means, eigvec, scores);

    /* 5) Reconstruct & MSE */
    float recon[BATCH_M][N_VARS];
    reconstruct_from_scores(means, eigvec, scores, recon);
    float mse = compute_mse_internal(recon);

    /* 6) total variance and savings estimate */
    float tot_var = compute_total_variance(means);
    float savings_pct = 0.0f;
    if (tot_var > 1e-12f) savings_pct = (1.0f - (mse / tot_var)) * 100.0f;
    if (savings_pct < 0.0f) savings_pct = 0.0f;

    /* 7) Print report (use dbg_print implemented in main) */
    dbg_print("\r\n=== PCA PRUNE REPORT ===\r\n");
    dbg_print("Samples: %d  N_VARS: %d  BATCH_M: %d\r\n", sample_count, N_VARS, BATCH_M);

    dbg_print("eigvec: ");
    for (int j = 0; j < N_VARS; ++j) dbg_print("%.4f ", eigvec[j]);
    dbg_print("\r\nmeans: ");
    for (int j = 0; j < N_VARS; ++j) dbg_print("%.3f ", means[j]);
    dbg_print("\r\nMSE=%.6f  TotVar=%.6f  EstimatedSavings=%.2f%%\r\n",
              mse, tot_var, savings_pct);
    dbg_print("========================\r\n");

    /* Reset batch */
    zero_buf();
    last_run_ms = now_ms;
    return 1;
}






#include "debug_print.h"
#include <stdio.h>
#include "usart.h" /* provides extern UART_HandleTypeDef huart3 */

void debug_print_init(void) {
    /* nothing for now; kept for future use */
}

/* route printf to huart3 */
#ifdef __GNUC__
int __io_putchar(int ch) {
#else
int fputc(int ch, FILE *f) {
#endif
    uint8_t c = (uint8_t)ch;
    HAL_UART_Transmit(&huart3, &c, 1, HAL_MAX_DELAY);
    return ch;
}

void print_hex_buf(const uint8_t *buf, unsigned len) {
    for (unsigned i = 0; i < len; ++i) {
        printf("%02X ", (unsigned)buf[i]);
        if ((i & 15) == 15) printf("\r\n");
    }
    printf("\r\n");
}

